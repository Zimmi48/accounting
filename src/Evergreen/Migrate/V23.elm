module Evergreen.Migrate.V23 exposing (..)

{-| This migration file was automatically generated by the lamdera compiler.

It includes:

  - A migration for each of the 6 Lamdera core types that has changed
  - A function named `migrate_ModuleName_TypeName` for each changed/custom type

Expect to see:

  - `Unimplement–µd` values as placeholders wherever I was unable to figure out a clear migration path for you
  - `@NOTICE` comments for things you should know about, i.e. new custom type constructors that won't get any
    value mappings from the old type by default

You can edit this file however you wish! It won't be generated again.

See <https://dashboard.lamdera.app/docs/evergreen> for more info.

-}

import Dict
import Evergreen.V16.Types
import Evergreen.V23.Types
import Lamdera.Migrations exposing (..)
import List


frontendModel : Evergreen.V16.Types.FrontendModel -> ModelMigration Evergreen.V23.Types.FrontendModel Evergreen.V23.Types.FrontendMsg
frontendModel old =
    ModelUnchanged


backendModel : Evergreen.V16.Types.BackendModel -> ModelMigration Evergreen.V23.Types.BackendModel Evergreen.V23.Types.BackendMsg
backendModel old =
    ModelMigrated ( migrate_Types_BackendModel old, Cmd.none )


frontendMsg : Evergreen.V16.Types.FrontendMsg -> MsgMigration Evergreen.V23.Types.FrontendMsg Evergreen.V23.Types.FrontendMsg
frontendMsg old =
    MsgUnchanged


toBackend : Evergreen.V16.Types.ToBackend -> MsgMigration Evergreen.V23.Types.ToBackend Evergreen.V23.Types.BackendMsg
toBackend old =
    MsgUnchanged


backendMsg : Evergreen.V16.Types.BackendMsg -> MsgMigration Evergreen.V23.Types.BackendMsg Evergreen.V23.Types.BackendMsg
backendMsg old =
    MsgUnchanged


toFrontend : Evergreen.V16.Types.ToFrontend -> MsgMigration Evergreen.V23.Types.ToFrontend Evergreen.V23.Types.FrontendMsg
toFrontend old =
    MsgUnchanged


migrate_Types_BackendModel : Evergreen.V16.Types.BackendModel -> Evergreen.V23.Types.BackendModel
migrate_Types_BackendModel old =
    { years = old.years |> Dict.map (\k -> migrate_Types_Year)
    , groups = old.groups |> Dict.map (\k -> migrate_Types_Group)
    , totalGroupCredits = old.totalGroupCredits |> Dict.map (\k -> Dict.map (\_ -> migrate_Types_Amount))
    , persons = old.persons
    , nextPersonId = old.nextPersonId
    , loggedInSessions = old.loggedInSessions
    }


migrate_Types_Amount : Evergreen.V16.Types.Amount a_old -> Evergreen.V23.Types.Amount a_new
migrate_Types_Amount old =
    case old of
        Evergreen.V16.Types.Amount p0 ->
            Evergreen.V23.Types.Amount p0


migrate_Types_Day : Evergreen.V16.Types.Day -> Evergreen.V23.Types.Day
migrate_Types_Day old =
    { spendings = old.spendings |> List.map migrate_Types_Spending
    , totalGroupCredits = old.totalGroupCredits |> Dict.map (\k -> Dict.map (\_ -> migrate_Types_Amount))
    }


migrate_Types_Group : Evergreen.V16.Types.Group -> Evergreen.V23.Types.Group
migrate_Types_Group old =
    old |> Dict.map (\k -> migrate_Types_Share)


migrate_Types_Month : Evergreen.V16.Types.Month -> Evergreen.V23.Types.Month
migrate_Types_Month old =
    { days = old.days |> Dict.map (\k -> migrate_Types_Day)
    , totalGroupCredits = old.totalGroupCredits |> Dict.map (\k -> Dict.map (\_ -> migrate_Types_Amount))
    }


migrate_Types_Share : Evergreen.V16.Types.Share -> Evergreen.V23.Types.Share
migrate_Types_Share old =
    case old of
        Evergreen.V16.Types.Share p0 ->
            Evergreen.V23.Types.Share p0


migrate_Types_Spending : Evergreen.V16.Types.Spending -> Evergreen.V23.Types.Spending
migrate_Types_Spending old =
    let
        ( credits, debits ) =
            separateCreditsAndDebits old.total old.groupCredits
    in
    { description = old.description
    , total = old.total |> migrate_Types_Amount
    , credits = credits |> Dict.map (\_ -> migrate_Types_Amount)
    , debits = debits |> Dict.map (\_ -> migrate_Types_Amount)
    , status = old.status |> migrate_Types_TransactionStatus
    }


{-| Convert stored groupCredits back to separate credits and debits
When total is negative, the logic is inverted: negative amounts become credits, positive become debits
-}
separateCreditsAndDebits (Evergreen.V16.Types.Amount total) groupCredits =
    let
        positive =
            groupCredits
                |> Dict.filter (\_ (Evergreen.V16.Types.Amount amount) -> amount > 0)
                |> Dict.map
                    (\_ (Evergreen.V16.Types.Amount amount) ->
                        if total < 0 then
                            -- For negative totals: convert positive amounts to negative
                            Evergreen.V16.Types.Amount -amount

                        else
                            -- For positive totals: keep positive amounts as positive
                            Evergreen.V16.Types.Amount amount
                    )

        negative =
            groupCredits
                |> Dict.filter (\_ (Evergreen.V16.Types.Amount amount) -> amount < 0)
                |> Dict.map
                    (\_ (Evergreen.V16.Types.Amount amount) ->
                        if total < 0 then
                            -- For negative totals: keep negative amounts as negative
                            Evergreen.V16.Types.Amount amount

                        else
                            -- For positive totals: convert negative amounts to positive debits
                            Evergreen.V16.Types.Amount -amount
                    )
    in
    if total < 0 then
        -- For negative totals: negative amounts are credits, positive amounts are debits
        ( negative, positive )

    else
        -- For positive totals: positive amounts are credits, negative amounts are debits
        ( positive, negative )


migrate_Types_TransactionStatus : Evergreen.V16.Types.TransactionStatus -> Evergreen.V23.Types.TransactionStatus
migrate_Types_TransactionStatus old =
    case old of
        Evergreen.V16.Types.Active ->
            Evergreen.V23.Types.Active

        Evergreen.V16.Types.Deleted ->
            Evergreen.V23.Types.Deleted

        Evergreen.V16.Types.Replaced ->
            Evergreen.V23.Types.Replaced


migrate_Types_Year : Evergreen.V16.Types.Year -> Evergreen.V23.Types.Year
migrate_Types_Year old =
    { months = old.months |> Dict.map (\k -> migrate_Types_Month)
    , totalGroupCredits = old.totalGroupCredits |> Dict.map (\k -> Dict.map (\_ -> migrate_Types_Amount))
    }
